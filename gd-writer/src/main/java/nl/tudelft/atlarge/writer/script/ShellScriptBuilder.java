package nl.tudelft.atlarge.writer.script;

import nl.tudelft.atlarge.writer.Global;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Date;
import java.util.LinkedList;
import java.util.Stack;

/**
 * Created by Chris Lemaire on 29-7-2017.
 */
public class ShellScriptBuilder {

    /**
     * {@link StringBuilder} to build the String that
     * should be outputted into the eventual script this
     * builder is building.
     */
    private StringBuilder outputBuilder;

    /**
     * {@link Stack} of {@link ShellScriptBuilder}s that
     * contains direct ssh script builders.
     */
    private Stack<ShellScriptBuilder> remoteScripts;

    /**
     * Whether this Builder is currently outputting to a
     * remote script.
     */
    private boolean writingOnRemote = false;

    /**
     * The remote the resulting ShellScript should be executed
     * at. This excludes inherited ssh remotes.
     * This is "localhost" for the first ShellScriptBuilder
     * in a chain.
     */
    private String sshRemote;

    /**
     * The {@link ShellScriptBuilder} hosting this script
     * and eventually starting this script through ssh.
     */
    private final ShellScriptBuilder parentBuilder;


    /**
     * The generated name of the file that should serve as
     * the ShellScript generated by this builder.
     */
    private final String name;

    /**
     * The path relative to the global script path at which
     * the output scripts should be stored.
     */
    private final String path;


    /**
     * A list of remotes traveled through starting with
     * localhost and ending with the current builder's
     * remote.
     */
    private final LinkedList<String> relayRemotes;

    /**
     * Constructs the first {@link ShellScriptBuilder}.
     */
    public ShellScriptBuilder(String scriptArchiveName) {
        this("localhost", null, new LinkedList<String>(), "/" + scriptArchiveName);
    }

    /**
     * Constructs any {@link ShellScriptBuilder} using
     * its remote, host builder and list of relay remotes.
     *
     * @param sshRemote remote at which the Script will be
     *                  executed.
     * @param host from which this builder is initialized.
     * @param relayRemotes all remotes in the ssh chain.
     * @param currentPath the current path.
     */
    private ShellScriptBuilder(String sshRemote, ShellScriptBuilder host,
                               LinkedList<String> relayRemotes, String currentPath) {
        outputBuilder = new StringBuilder();
        remoteScripts = new Stack<>();
        appendDefaultExportCommands();

        this.sshRemote = sshRemote;
        this.parentBuilder = host;
        this.path = currentPath + '/' + sshRemote;
        this.relayRemotes = new LinkedList<>(relayRemotes);
        this.relayRemotes.add(sshRemote);

        name = generateName();
    }

    /**
     * Generates a name for the ShellScript file.
     *
     * @return the name of the to-be-built ShellScript.
     */
    private String generateName() {
        String name = System.nanoTime() + "-";
        name += Global.RANDOM.nextInt(100000000);
        name += ".sh";

        return name;
    }

    /**
     * Gets the (remote) {@link ShellScriptBuilder} we will
     * currently be writing to.
     *
     * @return the currently active {@link ShellScriptBuilder}.
     */
    private ShellScriptBuilder getCurrentBuilder() {
        if (writingOnRemote) {
            return remoteScripts.lastElement().getCurrentBuilder();
        } else {
            return this;
        }
    }

    /**
     * Appends the contents of a line to the output of the
     * script. The newline character is added by this method.
     *
     * @param lineContents contents to be put in the line.
     * @return this builder.
     */
    public ShellScriptBuilder appendLine(String lineContents) {
        getCurrentBuilder().outputBuilder
                .append(lineContents)
                .append('\n');

        return this;
    }

    /**
     * Appends the contents of a line to the output of the
     * script and appends a command to store the output directly
     * in a temporary output file. The newline character is also
     * added by this method.
     *
     * @param lineContents command to be executed.
     * @return this builder.
     */
    public ShellScriptBuilder appendLineWithOutput(String lineContents) {
        getCurrentBuilder().outputBuilder
                .append(lineContents)
                .append(" |& tee -a ")
                .append(Global.OUTPUT_FILE)
                .append('\n');

        return this;
    }

    /**
     * Appends a call to the given remote script from this
     * host. This directly calls the script through a single
     * ssh server, not interpreting possible ssh relays.
     * @param remoteScript of which the ShellScript should
     *                            be called from this ShellScript.
     */
    private void appendScriptCall(ShellScript remoteScript) {
        appendLine(remoteScript.createRemoteCallCommand(sshRemote));
    }

    /**
     * Appends some default comments and commands to the start
     * of the Script.
     */
    private void appendDefaultExportCommands() {
        appendLine("#!/bin/sh");
        appendLine("# Created by " + getClass().getName() + " at "
                + Global.LOG_DATE_FORMAT.format(new Date(System.currentTimeMillis())) + ".");
        appendLine("");
        appendLine("# Default commands for script deployment follow.");
        appendLine("find $(dirname $0) -type f -regex \".*/*.sh\" | xargs --max-args=1 chmod +x");
        appendLine("find $(dirname $0) -mindepth 1 -maxdepth 1 -type d -printf '%f\\n' "
                + "| xargs -I % --max-args=1 scp -r ~"
                + Global.SCRIPT_PATH + " %:~" + Global.SCRIPT_PATH + "\n");
    }

    /**
     * Starts building a Script remotely. This means that further
     * appends to the Script will be redirected to the remote Script
     * we're building.
     *
     * @param sshAlias ssh alias of the server where the remote Script
     *                 will be executed.
     * @return
     */
    public ShellScriptBuilder startBuildingSshRemoteScript(String sshAlias) {
        ShellScriptBuilder currentBuilder = getCurrentBuilder();

        currentBuilder.remoteScripts.push(new ShellScriptBuilder(sshAlias, this, relayRemotes, path));
        currentBuilder.writingOnRemote = true;

        return this;
    }

    /**
     * Stops building a Script remotely by finishing the (most)
     * remote Script and returning the result.
     *
     * @return the ShellScript object returned by {@link #finish()}.
     * @throws IOException when something goes wrong in the {@link #finish()}
     *          call.
     * @throws IllegalStateException when this {@link ShellScriptBuilder}
     *          is not currently writing a remote Script.
     */
    public ShellScript stopBuildingSshRemoteScript() throws IOException {
        if (writingOnRemote && remoteScripts.lastElement().writingOnRemote) {
            return remoteScripts.lastElement().stopBuildingSshRemoteScript();
        } else if (writingOnRemote) {
            writingOnRemote = false;
            ShellScript script = remoteScripts.lastElement().finish();
            appendScriptCall(script);
            return script;
        } else {
            throw new IllegalStateException("Not currently writing on remote.");
        }
    }

    /**
     * Finishes the Script by finishing all its remote scripts
     * and thereafter creating the directories and file for
     * the Script and writing the output to the created file.
     *
     * @return ShellScript object with important data about the
     *          Script.
     * @throws IOException when something goes wrong when creating
     *          either the directories or the file or when writing
     *          to the created file.
     */
    public ShellScript finish() throws IOException {
        while (writingOnRemote) {
            stopBuildingSshRemoteScript();
        }

        String fullPath = Global.NATIVE_HOME + Global.SCRIPT_PATH + path;

        System.out.println("Creating script directory: '" + fullPath + "'");
        Files.createDirectories(Paths.get(fullPath));

        System.out.println("Creating script file: '" + fullPath + "/" + name + "'");
        Files.createFile(Paths.get(fullPath + "/" + name));
        Files.write(Paths.get(fullPath + "/" + name), outputBuilder.toString().getBytes());

        System.out.println("Finished building Script '" + name + "' at '"
                + fullPath + "/" + name + "'");

        return new ShellScript(name, path, sshRemote, relayRemotes);
    }

}
